

Parameters: <spam_PoW_number_of_past_blocks>
            <spam_PoW_difficulty>
            <spam_PoW_hash_version>
            <spam_PoW_number_of_tx_per_block>
            <spam_PoW_increasing difficulty>
            
To authorize a transaction, it needs to be tied to a past block using a proof of work.
To this end, the hash of the block, a transaction identifyer, are fed into a hash 
function together with a padding; the proof of
work is to find a padding that results in a hash that ends on <difficulty>
zeroes.

Thus, the flow is as follows:
 The user generates a unique transaction identifyer tid
 The user downloads the hash H(b) of the latest block it has seen, and computes
 brute forces valuies of x so that hash("Vega_SPAM_PoW", H(b),tid, x) starts with
 <difficulty> zeros.
 The user then attaches the PoW to a transaction, and sends it of together with x and H9b).
 
 The validators verify that
   H(b) is the correct hash of a past block
   That block is no more than <spam_PoW_number_of_past_blocks> in the past.
        This check is primarily done by the leader (i.e., block creator). On agreeing
        on a new block, all parties check their mempool for now outdated transactions and purge them.
   The hash is computed correctly and begins with <spam_PoW_difficulty> zeroes
   
Furthermore, the validators check than
  The same identifyer has not been used for another transaction from a previously comitted block. If the same identifyer is used for several transactions in the same block, these transactions need to be removed during post-processing, and the initiator blocked as a spammer.
  
  The same block has not been used for more than <spam_PoW_number_of_tx_per_block> transactions
 
 Violations of the latter rules cannot lead to a transaction being removed, as different validators have a different view on 
 this; however, they can be verified post-agreement, and the offending vega-key can be banished for 4 epochs.


Notes: 
- We do not require to feed the hash of the actual transaction into to hash function;
this allows users to pre-compute the PoW and thus allows them to perform low
latency transactions.
- As for replay protection, there is a danger that a trader communicates with a slow validator,
  and thus gets a wrong block number. The safest is to check validators worth > 1/3 of the 
  weight and take the highest block hash.


If increasing difficulty is set to 1, then more trnasactions can be tired to one block by increasing the difficulty; 
e.g., if transactions_per_block is 5 and difficulty is 7, then a 6. transaction can be tied to the same block
with difficulty 8, the 11th would have difficulty 9, etc.


Hash function:
The hash-function used is SHA3 <pending verification>. To allow for a more fine-grained control over the difficulty
of the Pow (the number of zeros only allows halving/doubling), the parameter <spam_PoW_hash_function> allows to 
increase the number of rounds of the hash function (currently 24), e.g., <spam_PoW_hash_function> = "sha3_36_rounds".
The parameter can in th future also be used to replace the SHA-3 through a governance vote (assuming other functions
have been made available by then) should this prove necessary.



Acceptance Criteria:
A message with a missing/wrong PoW is rejected
Reusing the same PoW for several messages is detected and leads to a blocking of the account
Linking too many transactions to the same block is detected and leads to a blocking of that account
A blocked account is unblocked after 4 epochs.
